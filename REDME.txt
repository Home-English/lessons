
Я разработчик ПО с четырех-летним стажем.
Я специализируюсь в области Java.
Мне приходилось разрабатывать разного рода приложения:
- десктопные Java приложения;
- мобильные Java приложения;
- веб приложения;
Я разрабатывал ПО с помощью следующих языков программирования: Java, JavaScript, C/C++, C#, SQL, PL/SQL, CSS...

Моим первым местом работы была компания HostingMax.
Это было в 2007-2008 году.
Моими обязаностями являлось разработка мобильных игр для мобильных платформ (Nokia, Samsung, Simens, Alkatel, BlackBarry..).
Здесь я познакомился и изучил технологии J2ME, (Java Media Framework, Mobile Information Device Profile).
А также я разрабатывал мобильную службу SyncML для синхронизации и восстановления персональных данных в мобильных устройствах.

Последним моим местом работы является компания ПриватБанк.
Это было в 2012-1016 год.
Моими обязанотями являлось разработка веб-сервисов для банковских услуг.
Здесь применялись технологии: Cuncurrent Collection, J2EE, Spring, AJAX, JQuery, AngularJS, Vaadin.
Использовались базы данных MySQL, IQ/ASE, Redis, MongoDB.
Я самостоятельно вел разработку одного отдельного проекта (это корпоративный проект).
И был участником в группе где разрабатывались разные веб-сервисы (это сервлеты, ActiveMQ, REST, SOAP - JAX-WS/JAX-RS).
Программный код покрывался JUnit, JMock и DBUnit тестами.
Также для глобального тестирования применялись инструменты: SonarQube, SoapUI, JMeter.
В приложении было включено логирование (Log4j).

Кроме веб-сервисов я разрабатывал библиотечные классы (которые потом использовались этими веб-сервисами).
Все разработки велись на Linux системе.
В качестве сборщика использовал ANT, Meven.
Системы контроля версий SVN, GIT.

Более всего мне запомнился проект сервиса для платежной системы.
Здесь применялись технологии: Java-7, Spring-3 (Data/Security/MVC/REST), (ORM-framework) JPA/Hibernate-3
База данных IQ, PostgreSQL.
Этот сервис использовал LiqPay.
Требовалось разработать библиотечные классы для применнеия этим приложением.
Общение с сервисом внутри приложения выполнялось через SOAP-протокол.

+++++++++++++++++++
+++++++++++++++++++
I am an IT developer with 4 years of experience.
I have spent the last four years developing my skills as a banking applications and been promoted once.
My first job was as an developer for mobile soft at HostingMax company.
I am expert in managing teams and solving customer problems.
Although I love my current role, I feel IТm now ready for a more challenging assignment.

I can summarize who I am in so: 
- Hardworking;
- I am quiet working under pressure; 
- I have an open mind about what will work best; 
- Attention to all the details; 
- Able to keep deadlines successfully;
- Fast-learner, self-motivated and determined;

I have a stable work history.
I think one of my greatest strengths is as a problem solver.
I have the ability to see a situation from different perspectives and I can get my work done even in the face of difficult obstacles.

Nobody is perfect.
I get impatient with team members who are making mistakes or delivering substandard work.

*   >>> http://lelang.ru/english/series/garri-potter-i-filosofskij-kamen-na-anglijskom-s-subtitrami/
*** >>> http://vasabi.tv/video/341-harry-potter-and-the-philosophers-stone/
        http://vasabi.tv/user/profile/admin/
		http://vasabi.tv/video/91-breaking-bad-sezon-1-epizod-1/
*   >>> (harry-potter-and-the-philosopher's-stone books) http://www2.sdfi.edu.cn/netclass/jiaoan/englit/download/Harry%20Potter%20and%20the%20Sorcerer's%20Stone.pdf
+ + + + + + + + + +
+ + + + + + + + + +
>> (5 простых правил порядка слов в английском) http://skyeng.ru/articles/5-prostyh-pravil-poryadka-slov-v-anglijskom
                                                https://www.native-english.ru/grammar/word-order
											  ( http://online-teacher.ru/study/english-predlogi-mesta )

|ОБСТОЯТЕЛЬСТВО МЕСТА-ВРЕМЕНИ| + [ПОДЛЕЖАЩЕЕ-СУЩЕСТВИТЕЛЬНОЕ] + [СКАЗУЕМОЕ-ГЛАГОЛ] + |ДОПОЛНЕНИЕ-ПРИЛАГАТЕЛЬНОЕ СУЩЕСТВИТЕЛЬНОЕ| + |ОБСТОЯТЕЛЬСТВО МЕСТА/ВРЕМЕНИ-ПРИЛАГАТЕЛЬНОЕ|

We (подлежащее) do (сказуемое) our work (дополнение) with pleasure (обстоятельство места и времени).
Мы [существительное] делаем [глагол] нашу работу [дополнение-существительное] с удовольствием [прилагательное].

At the moment I cannot talk.
В настоящий момент я не могу говорить.
В настоящий момент (дополнение-места/времени) ... я (кто?) не могу (дополнение) говорить (что делать?)

There is a great difference between her wishes and his possibilities.
ЧТО-ТО-НЕЧТО ГДЕ-ТО-ТАМ существует огромная разница между ее желаниями и его возможностями.
= = = = =
(что?) ... существует (что делает?) огромная (какая?) разница (дополнение-что?) ... 

---------------[ Глагол ]----------------------------[ ЧТО ДЕЛАТЬ?
Achieve ........ достигать (цели) / добиваться (чего-либо) [ ЭЧИИВ ]
Acquaint ....... знакомить / познакомить ..................... (аск-ить спрашивать/знакомить) [ ЭКВЭЙНТ ]
Accompany ...... сопровождать
Allow .......... позволять
Believe ........ верить / полагать
Confirm ........ подтвержденный .............................. ()
Consider ....... рассматривать, обдумывать, учитывать
Contribute ..... содействовать (вносить вклад)
Decide ......... решать (принимать решение)
Deliver ........ доставлять .................................. (доставки-почты-Deliver)
Develop ........ разрабатывать
Detect ......... обнаружить
Determine ...... определенный / решившийся ................... (де-уже есть решение)
Discover ....... открывать
Drop Fall ...... падать
Ensure Assure Quarantee  гарантировать
Exist .......... существовать ................................ (наличие выхода)
Granulate ...... дробить
Happen ......... случаться
Find ........... находить
Follow (Stick) . следовать (идти за кем-то) / (придерживаться позиции)
Invite ......... приглашать
Invoke ......... взывать / вызывать духов
Nested ......... вложенные
Maintain ....... поддерживать / обслуживать
Occur .......... происходить (действие)
Promote ........ способствовать / поощрять (повышения)
Prove .......... доказывать / подтверждать
Obtain ......... получать (что-либо) / добиваться (чего-либо)
Learn .......... учиться (самому учиться)
Look ........... осматривать (искать)
Keep Hold ...... держать / удерживать
React .......... реагировать
Reduce ......... уменьшить (reduces..уменьшает)
Receive ........ получать
Recover ........ востанавливать .............................. (ре-ооов, восстанавливать)
Recognize ...... признавать .................................. (организовывать запись)
Restrict ....... ограничивать ................................ (еластик деформирующий, нет четких границ)
Retrieve ....... извлекать ................................... (ре-iiiв, извлекать)
Search ......... поиск (искать)
Seem ........... казаться
Segregate ...... отделять / разделяться
Solve .......... решать (находить выход)
Summarize ...... резюмировать ................................ (суммировать)
Should ......... должен
Spot ........... обнаруживать (пятно)
Teach (Taught) . учить / научить (учить кого)
Terminate ...... завершаться ................................. (термiн дii)
Worry .......... беспокоится / волноваться

---------------[ Имя существительное ]---------------[ ЧТО? || дополнение
Appointment .... деловое свидание / условленная встреча
Ability ........ способный ................................... (он имеет возможность/способность быть обильным/щедрым)
Activity ....... деятельность
Addition ....... дополнение
Acquisition .... приобретение
Advantage ...... преимущество
Approach ....... подход (подход к решению)
Approximately .. примерно / приближенное значение
Assignment ..... присваивание
Attention ...... внимание
Being .......... являющийся / существующий (бытие)
Behavior Conduct поведение
Blend .......... смесь
Case (happen) .. случай / обстоятельство / прецедент / какое-то дело (судебное дело, засвидетельствованный случай, достоверный случай)
Сause Reason ... причина
Contribution ... взнос / вклад
Challenge ...... сложная задача / проблема (вызов ~ как на соревнование) ................... (челенджер много дисков, сложный)
Contraction .... сокращение (выразить в сокращенной форме)
Сonfidence ..... доверие (достоверность)
Companion ...... попутчик
Compression .... сжатие (что-либо сжимать)
Cover .......... покрытие (что-либо покрывать)
Decrease Reduction  уменьшение
Degree ......... степень
Development .... разработка
Equipment ...... оборудование
Entity ......... сущность (объект)
Execution ...... выполнение
Exchange ....... размен / обменный
Existence ...... существование / наличие
Experience ..... опыт / стаж
Expression ..... выражение
Event .......... событие
Feature ........ особенность
Fluency ........ плавность / беглость
Frequency ...... частота
Instance ....... пример
Inverse ........ обратный порядок
Impact ......... воздействие / влияние
Improvement .... улучшение
Grab ........... схватывать / захватывать
Hand ........... рука
Hope ........... надежда
Maybe (Might) .. может быть (мог бы)
Matter Matters . вопрос / вопросы
Mean ........... означать
Meet Meeting ... встречать / знакомиться (встреча)
Must ........... должен
Note ........... примечание (записка)
Occurrence ..... происшествие (случай, эпизод) ............... (of frequent occurrence - часто встречающийся | of rare occurrence - редко встречающийся)
Lock ........... замок (закрыть на замок)
Permit ......... разрешать
Possibility .... возможность
Promise ........ обещание
Purpose ........ назначение
Opportunity .... благоприятная возможность ................... (благооо-возможность)
Obstacle ....... помеха / препятствие / преграда ............. (оп, спостыкаться)
Kinds of ....... разновидность тип/вид/род/сорт
Reception ...... приемная (приемная комната)
Reduction ...... уменьшение
Relation Dependency  зависимость / отношение / связь
Release ........ высвобождение / освобождение / версия
Resolve Resolution  решительность
Responsibility . ответственность, обязанность
Rule ........... правило
Sense Semantics  смысл
Strength ....... сильные стороны ............................. (де-та-сторона сильная)
Solution ....... решение
Study .......... изучение
Substance ...... вещество
Target ......... цель (мишень)
Track .......... след / дорога (от чего либо, для чего либо)
Troubles Trouble неприятности / беда
Throw Cast ..... бросать
Vocabulary ..... запас слов
Wish ........... желаниe ..................................... (и жжжелаю..)

---------------[ Имя прилагательное ]----------------[ КАКОЙ?
Able ........... способный ................................... (возможность/способность быть обильным/щедрым)
Alone .......... без посторонней помощи, не разделяемый другими
Better ......... лучше
Complete ....... законченный, совершенный
Clean .......... чисто
Clear .......... ясно / все ясно
End (Ended) .... конец (законченный)
High ........... высокий
Great Greatest . великий / величайший
Impatient ...... нетерпящий
Native ......... родной
Nice ........... приятный
Meaning ........ значащий
Missing ........ потерявшийся / отсутствующий
Minor .......... незначительный
Significant .... значительный
Following ...... следующий
Relevant ....... уместный / соответствующий
Shy Embarrass .. застенчивый (стеснятся, смущять)
Still Yet ...... еще / все еще
Similar ........ похожий
Single ......... один
Strong ......... сильный ..................................... (он сильный)
Stuck .......... застрявший
Substandard .... нестандартный ............................... (под стандартном)
Various ........ разнообразный
Verbose ........ многословный
Taller ......... более высокий
Typical ........ типичный
Worse .......... хуже

---------------[ Наречие ]---------------------------[ КОГДА?
Above .......... выше
Absolutely ..... абсолютно
Always ......... всегда
Already ........ уже (уже сделал)
Back  .......... назад / обратно
Below .......... ниже
Counter Backward обратно / в обратном направлении
Direct ......... прямо
Exactly (Just) . точно / точь-в-точь / именно / как раз / совершенно верно (прямо в точку)
Excellent ...... отлично
Forever ........ навсегда
Just ........... просто / как раз / только что / совершенно верно (точно, как раз, именно, поистине)
Quite .......... вполне / весьма / довольно / достаточно
Often Frequently  часто
Instead ........ вместо / взамен
Simply ......... просто
Straight ....... метко (прямо в яблочко)
Recently ....... недавно / в последнее время ................. (востанновления недавних событий в памяти, воспоминания)
Together ....... вместе

---------------[ Союз ]------------------------------[ +
Above .......... выше
According ...... в соответствии
Across ......... поперек
Anyway ......... как бы то ни было, во всяком случае, в любом случае
Although ....... несмотря на то что / хотя ................... (сквозь препятствие)
Almost ......... почти
Because ........ потому что
However ........ однако / какой бы ни
Fortunately .... к счастью
Unfortunately .. к сожалению (не к счастью)
Since .......... поскольку
Therefore ...... поэтому
Whether ........ ли / будь то

---------------[ Сокращение ]------------------------[
Gonna .......... собираться вместе / собираться сделать
Over .......... над
Goodness ...... доброта / великодушие

---------------[ ??? ]------------------------[
  WHAT ? ...... что/какой ?
   WHO ? ...... кто ?
 WHERE ? ...... где ?
  WHEN ? ...... когда ?
   WHY ? ...... почем/зачем ?
   HOW ? ...... как ?


>> (Полиглот английский за 16 часов. Урок 3 с нуля ** 34:02) https://www.youtube.com/watch?v=qg9NhobhbTg

               Прошлое | Настоящее | Будущее
   +------+ +---[BE]---+---[BE]----+--[BE]---+
   | I    | |          | AM        |         |
   +------+ |          +-----------+         |
   | HE   | | WAS      |           |         |
   | SHE  | |          | IS        |         |
   | IT   | |          |           | WILL    |
   +------+ +----------+-----------+         |
   | YOU  | |          |           |         |
   | WE   | | WERE     | ARE       |         |
   | THEY | |          |           |         |
   +------+ +----------+-----------+---------+

                                  Вопрос        |              Утверждение            |       Отрицание
   +------------------+ +-----------------------+-------------------------------------+-----------------------+
   |                  | |      I .......        | I .......................           | I .....               | Б
   |                  | |      HE ......        | HE ......................           | HE ....               | у
   |                  | |      SHE ..... [BE] ? | SHE ..................... WILL [BE] | SHE ... WILL NOT [BE] | д
   | WILL             | | WILL IT ...... love?  | IT ......................      love | IT ....          love | у
   |                  | |      YOU ..... see?   | YOU .....................      see  | YOU ...          see  | щ
   | 	              | |      WE ......        | WE ......................           | WE ....               | е
   |                  | |      THEY ....        | THEY ....................           | THEY ..               | е
   +------------------+ +------[окончания]------+-----[окончания|процесс]-------------+------[окончания]------+--
   |           |      | | [AM] ... I ....       | I ......      | I ..... AM          | I ......              | Н
   |           |      | | DO ............ love? | ........ [DO] | ......              | ........              | а
   | DO        |      | |       .. YOU .. see?  | YOU .... love | YOU ..              | YOU .... DON'T love   | с
   |           |      | | [ARE] .. WE ...       | WE ..... see  | WE ... ARE [DO+ING] | WE .....       see    | т
   |           | +ING | |       .. THEY .       | THEY ...      | THEY .     loving   | THEY ...              | о
   | - - - - - |      | | - - - - - - - - - - - | - - - - - - - | ......     seeing   | - - - - - - - - - - - | я
   |      |    |      | | [IS] ... HE ... love? | HE ... [DO+S] | HE ....             | HE ..... DOESN'T love | щ
   | DOES | +S |      | | DOES ... SHE .. see?  | SHE .. loves  | SHE ... IS          | SHE ....         see  | е
   |      |    |      | |      ... IT ...       | IT ... sees   | IT ....             | IT .....              | е
   +------------------+ +-----------------------+-------[неправильные глаголы]--------+-----------------------+--
   |                  | |      ........ I       | I ......      | I ...........       | I ....                | П
   |                  | |      ....... HE       | HE .....      | HE ..........       | HE ...                | р
   |                  | | [BE] ...... SHE ?     | SHE .... WAS  | SHE ......... [ED]  | SHE ..        [BEN'T] | о
   |                  | | DID ........ IT love? | IT .....      | IT .......... loved | IT ... DIDN'T love    | ш
   | DID  | +ED       | |     ........... see?  |          [BE] | ............. saw   | ......        see     | е
   |(HAVE)            | |     ....,.. YOU       | YOU ....      | YOU .........       | YOU ..                | д
   |                  | |     ....,... WE       | WE ..... WERE | WE ..........       | WE ...                | ш
   |                  | |     ..,... THEY       | THEY ...      | THEY ........       | THEY .                | е
   |                  | |                       |               |                     |                       | е
   +------------------+ +-----------------------+-------------------------------------+-----------------------+

>> https://www.google.com.ua/imgres?imgurl=http%3A%2F%2F4.bp.blogspot.com%2F-_BM_GaVi0QM%2FUbcDir066uI%2FAAAAAAAAAMY%2F4rFkG3GJs-0%2Fs1600%2FIRREGULAR%2BVERBS.jpg&imgrefurl=http%3A%2F%2Fruthhernandezcornejo.blogspot.com%2F&docid=5tS7ElJp5czrYM&tbnid=naFd-VT5yKBdAM%3A&w=1024&h=724&bih=791&biw=1600&ved=0ahUKEwiX__WB7InQAhVLVSwKHQY-BNAQMwgiKAcwBw&iact=mrc&uact=8

        Настоящее                 Прошедшее                (Прошедшее)
--------[PRESENT]--------+------[PAST SIMPLE]------+----[PAST PARTICIPLE]----+---------------------
 cut        (кат)        | cut        (кат)        | cut        (кат)        | резать
 let        (лэт)        | let        (лэт)        | let        (лэт)        | позволять
 read       (рид)        | read       (рид)        | read       (рид)        | читать
 put        (пут)        | put        (пут)        | put        (пут)        | класть/ложить
 shut       (шут)        | shut       (шут)        | shut       (шут)        | преградить / затворять
 cost       (кост)       | cost       (кост)       | cost       (кост)       | стоить
                         +                         +                         +
 hit        (хэйт)       | hit        (хэйт)       | hit        (хэйт)       | ударять/попадание
 - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - 
 get        (гэт)        | got        (гот)        | got        (гот)        | получать
 sit        (сит)        | sat        (сэт)        | sat        (сэт)        | сидеть
                         +                         +                         +
 meet       (миит)       | met        (мэт)        | met        (мэт)        | встречать
 keep       (киип)       | kept       (кэпт)       | kept       (кэпт)       | держать
 feel       (фиил)       | felt       (фэлт)       | felt       (фэлт)       | чувствовать
 leave      (лиив)       | left       (лэфт)       | left       (лэфт)       | оставлять
 sleep      (слип)       | slept      (слэпт)      | slept      (слэпт)      | спать
                         +                         +                         +
 lend       (лэнд)       | lent       (лэнт)       | lent       (лэнт)       | давать взаймы
 send       (сэнд)       | sent       (сэнт)       | sent       (сэнт)       | отправлять
 spend      (спэнд)      | spent      (спэнт)      | spent      (спэнт)      | тратить
 build      (билд)       | built      (билт)       | built      (билт)       | строить
 learn      (лерн)       | learnt     (лернт)      | learnt     (лернт)      | учиться
 lose       (лууз)       | lost       (лост)       | lost       (лост)       | терять
                         +                         +                         +
 catch      (кэч)        | caught     (каутс)      | caught     (каутс)      | поймать
 buy        (бай)        | bought     (бутс)       | bought     (бутс)       | купить
 bring      (брин)       | brought    (боутс)      | brought    (боутс)      | приносить
 think      (синк)       | thought    (соутс)      | thought    (соутс)      | думать
 teach      (тич)        | taught     (тоутс)      | taught     (тоутс)      | учить
 - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - 
 can        (кэн)        | could      (кууд)       | could      (кууд)       | можно
 pay        (пэй)        | paid       (пэйд)       | paid       (пэйд)       | платить
 say        (сэй)        | said       (сэйд)       | said       (сэйд)       | сказать
 have       (хэв)        | had        (хэд)        | had        (хэд)        | иметь
 make       (мэйк)       | made       (мэйд)       | made       (мэйд)       | делать
                         +                         +                         +
 win        (вин)        | won        (вон)        | won        (вон)        | побеждать
                         +                         +                         +
 tell       (тэлл)       | told       (туд)        | told       (туд)        | рассказывать
 sell       (сэлл)       | sold       (соуд)       | sold       (соуд)       | продавать
 stand      (стэн)       | stood      (студ)       | stood      (студ)       | стоять
 understand (андэстэнд)  | understood (андэстууд)  | understood (андэстууд)  | понимать
                         +                         +                         +
 find       (файнд)      | found      (фоуд)       | found      (фоуд)       | находить
 hear       (хиа)        | heard      (хеод)       | heard      (хеод)       | слышать
 - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - 
 come       (кам)        | came       (кэм)        | come       (кам)        | приходить
 become     (бикам)      | became     (бикэм)      | become     (бикам)      | становиться
 - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - 
 drive      (драйв)      | drove      (дров)       | driven     (дривн)      | ездить
 write      (райт)       | wrote      (рот)        | written    (ритн)       | писать
                         +                         +                         +
 eat        (ит)         | ate        (эт)         | eaten      (итн)        | кушать
                         +                         +                         +
 give       (гив)        | gave       (гэв)        | given      (гивн)       | давать
 wear       (вир)        | wore       (вор)        | worn       (ворн)       | носить
 speak      (спик)       | spoke      (спок)       | spoken     (спокн)      | говорить
 steal      (стил)       | stole      (стол)       | stolen     (столен)     | воровать
                         +                         +                         +
 wake       (вэйк)       | woke       (вок)        | woken      (вокн)       | просыпаться
 break      (брэк)       | broke      (брок)       | broken     (брокн)      | ломать
 choose     (чууз)       | chose      (чооз)       | chosen     (чузн)       | выбирать
 - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - 
 grow       (гроу)       | grew       (грэу)       | grown      (гроун)      | расти
 know       (ноу)        | knew       (нэу)        | known      (ноун)       | знать
 throw      (сроу)       | threw      (срэу)       | thrown     (сроун)      | бросать
                         +                         +                         +
 fly        (флай)       | flew       (флу)        | flown      (флоун)      | летать
 - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - 
 take       (тэйк)       | took       (тук)        | taken      (тэккэн)     | брать
 fall       (фоол)       | fell       (фэл)        | fallen     (фолэн)      | падать
 forget     (фогэт)      | forgot     (фогот)      | forgotten  (фоготн)     | забывать
 - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - 
 begin      (бэгин)      | began      (бигэн)      | begun      (биган)      | начинать
 drink      (дринк)      | drank      (дрэнк)      | drunk      (дранк)      | пить
 ring       (рин)        | rang       (рэн)        | rung       (ран)        | звонить
 run        (ран)        | ran        (рэн)        | run        (ран)        | бежать
 sing       (син)        | sang       (сэн)        | sung       (сан)        | петь
 swim       (свим)       | swam       (свэм)       | swum       (свам)       | плавать
 - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - 
 do         (ду)         | did        (дид)        | done       (дан)        | делать
 go         (гоу)        | went       (вэнт)       | gone       (гон)        | идти
 - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - - - + - - - - - - - - - - 
 be         (би)         | was(were)  (воз)        | been       (бин)        | быть
 see        (сии)        | saw        (со)         | seen       (син)        | видеть
-------------------------+-------------------------+-------------------------+---------------------

>> (EnglishLessons4U - Learn English with Ronnie) https://www.youtube.com/channel/UC4cmBAit8i_NJZE8qK8sfpA


I am a software developer with five-years of experience.
I specialize in the area of Java/JavaScript and Scala.
I had to develop different kinds of applications:
- The desktop Java applications;
- The mobile Java applications;
- And the web applications;
I developed the software using following programming languages: Java, JavaScript, C/C++, C#, SQL, PL/SQL, CSS ...(for example)

My first job was the "HostingMax" company.
It was in the 2007-2008 year. (start twenty and seven last twenty and eight)
My responsibility is develop mobile games for mobile platforms (Nokia, Samsung, Simens, Alkatel, BlackBarry ..).
There acquainted and learned J2ME technology, (Java Media Framework, Mobile Information Device Profile).
And I developed a SyncML mobile service for synchronization and restoration of a personal data in mobile devices.

My last place of work is a at "PrivatBank" company.
It was in the 2012-2016 year. (start twenty and twelf last twenty and sixteen)
My responsibility was development of web-services for banking ..services.
There used technologyies: Cuncurrent Collection, J2EE, Spring, AJAX, JQuery, AngularJS, Vaadin.
We used a database: MySQL, IQ/ASE, Redis, MongoDB.
I was an alone development of one project (this corporate project).
And I was a member of the group for developed various web services (it servlets, ActiveMQ, REST, SOAP - JAX-WS/JAX-RS).
There is code covered by JUnit, JMock and DBUnit tests.
Also used tools for global testing: SonarQube, SoapUI, JMeter.
Apps had logging (it Log4j).

Addition I developed library classes (which are then used by these web services).
All developments were on a Linux system.
As a tools builder was used ANT, Maven.
Version control systems SVN, GIT.

Most of all I remember the service project for payment system.
There used technologyies: Java-7, Spring-3 (Data/Security/MVC/REST), ORM-framework (JPA/Hibernate-3)
Database: IQ, PostgreSQL, Redis.
This service was use LiqPay.
Was necessary develop library classes for use into this application.
Data communication with the service performed within the application throus SOAP-protocol.

I am expert in managing teams and solving customer problems.
Although I love my current role, I feel I am now ready for a more challenging assignment.
I have a stable work history.
I think one of my greatest strengths is as a problem solver.
I have the ability to see a situation from different perspectives and I can get my work done even in the face of difficult obstacles.
I can summarize who I am in so: 
- Hardworking;
- I am quiet working under pressure; 
- I have an open mind about what will work best; 
- Attention to all the details; 
- I able to keep deadlines successfully;
- Fast-learner, self-motivated and determined;

Nobody is perfect.
I get impatient with team members who are making mistakes or delivering substandard work.






В последнее время я участвовал в разрабатке проекта электронного магазина.
Я сам выбирал технологии которые нужно было приемнить для реализации задач бизнеса.
В состав этого электронного магазина входили модули:
- оплата
- авторизации
- банкинг
- система резервации
- AngularJS (1)
- 

> Рассказать об полиморфизме, инкапсуляции и наследованию в Java ?
  http://java-se-learning.blogspot.com/2013/07/blog-post_4.html
  Парадигмы объектно ориентированного программирования Java основаны на трёх основополагающих концепциях, называемых абстракция, инкапсуляция, наследование и полиморфизм.
  1. Абстракция - выделение важных особенностей, характеристик объекта, главным образом отличающего его от других объектов. Выделение главных особенностей, не вдаваясь в в подробности, не вдаваясь в детали.
  2. Полиморфизм - возможность одного интерфейса иметь различные реализация. Одна спецификация - много реализация. Для Java полиморфизм - это исключительно позднее связывание (runtime binding).
  3. Инкапсуляция - сокрытие реализации. Это значит что для объекта, который хочет сотрудничать(работать) с классом видны только поля, доступные в соответствии модификаторов доступа, и спецификации методов , доступные в соответствии модификаторов доступа. Реализация методов недоступна.
  4. Наследование - возможность создавать обобьет на основании другого объекта. Это означает что новый обобьет создается не "с нуля", а с шаблона родителя - набор свойств  и поведение (набор методов) будет унаследован от родителя.
> Какие существуют области памяти в Java ?
> Рассказать об одном из проектов который больше всех остальных мне запомнился ?
  Я принимал участвие в коммерческом проекте по публицированию объявлений.
  В частности я занимался разработкой системы авторизации + сыстемы оплаты + системы для резервирования заказов.
> Я занимаюсь автомобильным спортом.
  Участвую в соревнованиях на картингах на коротких и длинных дистанциях.
  Иногда мы собираемся с друзьями в команду и проводим соревнование между собой.
  Часто для соревнованиях мы выбираем разные трассы. И таким способом результаты каждого нового сорревнования становятся непредсказуемым.
  Еще мы собираем команду для туристического отдыха.
  Там мы устраиваем заезд на квадроциклах по бездорожью, по гористой местности.
  Это очень интересно и очень красиво.
  Также мы можем наблюдать разные пейзажи на природе.
  Мы получаем удовольствие из таких поездок и делимся между собой своми впечетлениями.
> Мое хобби - собирать разные радио-модели автомобилей.
  На сборку каждой модели можно потратить и один месяц и один год.
  Часто бывает сложно найти специфическую деталь для конкретной модели автомобиля.
  Иногда приходиться эту деталь делать самому.
  Часто бывает что плохо сдлеланная радио-модель автомобиля ломается на дороге во время езды.
  Поэтому я запасаюсь запасными деталями для каждой модели автомобиля.
  Я нравится собирать традиционные и классические автомобильные модели, с бензиновыми двигателями.
  Это очень тонкая работа и требует большого внимания и высокой точности выполнения. А также и терпение к длительному времени потраченому на создание каждой модели.
  Но мне это очень нравится.
> Я часто смотрю телепередачи о проведении спортивных чемпионатов авто-роллейных сорревнований между легковыми и грузовыми категориями, на коротких и длинных дистанциях.
  А также я смотрю и другие телевизионные авто-шоу, например: Топ-Гир.
  Подписываюсь и читаю спортивные журналы по автоспорту.
> 
>
>
> Мне ненравиться когда нарушаются ранее оговоренные сроки выполнения заданий.......
  Когда срывается план работы из-за плохо спланированых действий......

> Tell me about polymorphism, encapsulation and inheritance in Java?
  Paradigm of object oriented programming is based on three fundamental concepts: encapsulation, inheritance and polymorphism.
  1. Abstraction - this is the allocation of the main features, without going into details and details.
  2. Polymorphism - это возможность одного интерфейса иметь различные реализация.     it is posybylyty for any one interface has various implementations.     Одна спецификация - много реализация. Для Java полиморфизм - это исключительно позднее связывание (runtime binding).
  3. Encapsulation - сокрытие реализации. Это значит что для объекта, который хочет сотрудничать(работать) с классом видны только поля, доступные в соответствии модификаторов доступа, и спецификации методов , доступные в соответствии модификаторов доступа. Реализация методов недоступна.
  4. Inheritance - возможность создавать обобьет на основании другого объекта. Это означает что новый обобьет создается не "с нуля", а с шаблона родителя - набор свойств  и поведение (набор методов) будет унаследован от родителя.
> Какие существуют области памяти в Java ?
> I am go in for motor sports.
  I participate on sports events for karting in a short and long distances...........................................
  Sometimes we're going with friends to the team and to hold competitions among themselves.
  Often competitions we choose different routes. And in this way the results of each new sorrevnovaniya become unpredictable.
  Once we collect the team for leisure tourism.
  There we arrange check-ATV on the road, on a hilly terrain.
  It is very interesting and very beautiful.
  Also we can observe different views on the nature.
  We get pleasure from these trips and share with each other svomi vpechetlenie.
> My hobby - collecting various car radio models.
  and one month and one year can be spent on the assembly of each model.
  It is often difficult to find a specific item for a specific car model.
  Sometimes you do this part yourself.
  It often happens that bad sdlelannaya car radio model breaks down on the road while driving.
  So I stock up on spare parts for each model of car.
  I like to collect traditional and classic car models with petrol engines.
  It is very delicate work and requires a lot of attention and precision execution. And patience for the long time spent on the creation of each model.
  But I like it a lot.
> I often watch TV programs on the organization of sports-car championships rolleynyh sorrevnovany between passenger and freight categories for short and long distances.
  And as I watch television and other auto shows, for example: Top Gear.
  I subscribe and read sports magazines Motorsport.



+ ITERATOR | ITERABLE
  > Итератор - это паттерн который позволучить доступ к элементам любой коллекции без вникания в суть ее имплементации.
  > Iterable - это интерфейс который реализует этот Итератор
  >> (В чем отличия TreeSet и HashSet?) https://habrahabr.ru/post/162017/
     Set - не допускает хранение двух одинаковых элементов.
	 TreeSet - обеспечивает упорядоченно хранение элементов в виде красно-черного дерева.

+ https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/JPAExample.java
+ https://github.com/Home-GWT/TopLinkExample/blob/master/src/com/voituk/jpaexample/Spring.md

+ КОГДА СОЗДАЕТСЯ И УНИЧТОЖАЕТСЯ СЕССИЯ
  веб-сервер не поддерживает постоянного соединения с клиентом (каждый запрос обрабатывается как новый).
  Сеанс (сессия) - это механизм позволяющий однозначно идентифицировать браузер и создающий для этого браузера файл на сервере (в котором хранятся переменные сеанса).
  Сеансы используются для обеспечения хранения данных во время нескольких запросов Web-страницы
  -- http://crypto.pp.ua/2010/06/seans-sessiya-v-java/
     http://java.markune.ru/servlets/session-tracking.html
     --- getSession() - чтобы открыть новый сеанс ( метод объекта HttpServletRequest возвращает сессию пользователя ). Метод извлекает из запроса в сервлет объект сессии ( интерфейс HttpSession предоставляет методы, которые сохраняют и возвращают данные )
	     Если входной параметр равен true getSession(boolean param) то сервлет-контейнер проверяет наличие сеанса
	     В случае успеха метод возвращает дескриптор этого сеанса. В противном случае метод устанавливает новый сеанс.
			HttpSession session = request.getSession(true);
		 Если сессия не существует то ссылка на нее НЕбудет получена
			HttpSession session = req.getSession(false);
		 ................................................
		 invalidate - чтобы вручную завершить сессию
		 (Java) Web-сервер - автоматически завершает сессию (когда в течение определенного времени не происходит запросов, по умолчанию 30 минут)
		 ................................................
	 --- после чего начинается сбор информации о клиенте:
         setAttribute() - чтобы сохранить значения переменной в текущем сеансе
		 getAttribute() - чтобы прочесть значения
		 getAttributeNames() - список имен всех переменных в текущем сеансе
		 removeAttribute() - чтобы удалить значения
		 getId() - возвращает уникальный идентификатор который получает каждый сеанс при создании
		 isNew() - возвращает false для уже существующего сеанса и true – для только что созданного
		 invalidate() - завершить сеанс, уничтожает все связи с объектами, и данные, сохраненные в старом сеансе, будут потеряны для всех приложений
		 getCreationTime() и getLastAccessedTime() - информацию о дате и времени создания последнего обращения к сессии
	 --- время инвалидации (жизни) сессии можно задать с помощью тега session–config в web.xml в виде:
			<session-config>
				<session-timeout>30</session-timeout>
			</session-config>
     --- Как правило при работе с сессией возникают следующие проблемы:
	     поддержка распределенной сессии (синхронизация/репликация данных, уникальность идентификаторов и т.д.);
	     обеспечение безопасности;
	     проблема инвалидации сессии (expiration) предупреждение пользователя об уничтожении сессии;

+ INDEX (в базе данных)
  >> (Индексы. Теоретические основы) http://www.sql.ru/articles/mssql/03013101indexes.shtml
  >> (14 вопросов об индексах в SQL Server) https://habrahabr.ru/post/247373/
  Физически данные хранятся на 8Кб страницах. Сразу после создания, пока таблица не имеет индексов, таблица выглядит как куча (heap) данных.
  Когда вы хотите получить доступ к данным, SQL Server сканирует всю таблицу что бы найти искомые записи.
  SQL Server не знает что в таблице существует только одна запись, удовлетворяющая условию, пока в таблице не существует: 'Unique constraint', 'Unique index' или 'Primary key'.
  В SQL Server индексы хранятся в виде B-деревьев (B-tree). 'B' означает сбалансированное (не путать с бинарным). SQL Server предлагает к использованию два типа индекса: кластерный (clustered) и некластерный (nonclustered).
  Указатель представляет собой 'Row ID' и имеет следующий формат: НомерФайла:НомерСтраницы:ПозицияЗаписи.
  ( правило, когда работаете с SQL Server: запись может быть найдена либо по 'Row ID' когда нет кластерного индекса, либо по 'кластерному ключу' )
  
  Индексы которые созданные на базе ОДНОГО-поля таблицы:
  > Кластерный индекс - сами данные таблицы являются частью индекса, для таблицы может быть создан только один 'кластерный индекс'.
                        В SQL Server кластерный индекс является уникальным индексом по определению (все ключи записей должны быть уникальные).
	                    Если существуют записи с одинаковыми значениями, SQL Server делает их уникальными, добавляя номера из внутреннего (невидимого снаружи) счетчика.
						( 'Кластерный индекс' является частью 'не кластерного индекса' )
  > Не кластерный индекс - cами данные не хранятся в индексе и вынимаются из таблицы, используя 'Row ID' или ключ 'кластерного индекса' (важное правило SQL Server: создавать 'кластерные ключи' нужно как можно более короткими).
                           ( Каждый 'некластерный индекс' использует значения кластерного индекса, > увеличение размера 'кластерного индекса' приводит к многократному увеличению по памяти для всех 'не кластерных индексов' и к снижению количества записей индекса способных уместиться в пределах одной страницы )
  
  Индекс может быть создан на основании НЕСКОЛЬКИХ-полей:
  > Составной ключ - индекс создан на основании нескольких полей, и любая группа значений по полям составного индекса является уникальной.
                     ( существует только одно ограничение – длина ключа индекса или сумма длин этих полей не должна превышать 900 байтов )
  > Уникальные индексы - гарантирует что каждое значение является уникальным в индексируемом поле
                         ( целостность данных может быть гарантирована или 'Unique constrain' или 'primary key'. В основе обоих лежит уникальный индекс )

  Доступ к записям при наличии или отсутствии индексов
  > В зависимости от наличия/отсутствия индексов и их типов, SQL Server может выбрать различные способы доступа к данным таблицы:
    - Сканирование таблицы. ( Когда индексы не используются и таблица не имеет кластерного индекса. Таблица храниться как куча 'heap' )
	- Выборка данных по 'кластерному индексу'
	- Выборка данных по 'не кластерному индексу'

  Индексы так же имеют и ряд недостатков:
  > Индексы занимают дополнительное место на диске и в оперативной памяти ( каждый раз когда вы создается индекс, сохраняется ключи по порядку...и чем больше/длиннее ключ, тем больше размер индекса )
  > Замедляются операции вставки, обновления и удаления записей

+ JPA / HIBERNATE
+ JTA-ТРАНЗАКЦИИ
  http://khpi-iip.mipk.kharkiv.edu/library/j2ee/tutoral/doc/Transaction4.html
  https://www.ibm.com/developerworks/ru/library/0610_bicheno/
  http://www.k-press.ru/cs/2006/3/WAS/WAS.asp
  JTA (Java Transaction API) - API позволяет размечать транзакции способом не зависящим от реализации менеджера транзакций.
  Чтобы разметить JTA-транзакцию нужно вызывать методы: begin, commit и rollback ( интерфейса javax.transaction.UserTransaction )
  Если изменения дают сбой тогда вызывается метод rollback и выбрасывается EJBException
  .....................................................................................
   UserTransaction transaction = context.getUserTransaction();
   try {
      transaction.begin();
      updateChecking(amount);
      machineBalance -= amount;
      insertMachine(machineBalance);
      transaction.commit();
   } catch (Exception ex) {
       try {
          transaction.rollback();
       } catch (SystemException syex) {
           throw new EJBException
              ("Rollback failed: " + syex.getMessage());
       }
       throw new EJBException 
          ("Transaction failed: " + ex.getMessage());
    }
  .....................................................................................
  Основная идея использования JMS (Java Message Service) заключается в том, что разработчики создают только клиентские приложения, часть из которых является отправителями, а часть – получателями сообщений.
  > JMS-Сервер (его называют 'message broker') его просто используют подобно Web-серверам...
  > Перед началом работы программы использующей JMS на стороне JMS-сервера создаются «администрируемые объекты», это:
    - фабрики соединений (connection factories)
    – «целевые» объекты двух видов (топики 'topics' и очереди 'queues')
  > Основное отличие топиков от очередей состоит в том что:
    - очередь является просто каналом передачи сообщения единственному потребителю (реализуют программную модель «отправитель-получатель» sender-receiver)
    - а топики размножают сообщение для всех кто желает его получить (реализуют программную модель «издатель-подписчик» (publisher-subscriber)
  > Получатель сообщений может извлекать сообщения в двух режимах:
    1. синхронном - программа-получатель явно вызывает метод receive().
	                Если сообщения доступно - тогда метод возвращает сообщение; а если сообщения нет - тогда метод блокирует поток и программа ждет прихода сообщения
	2. и асинхронном - получатель реализует callback-метод onMessage() специального интерфейса MessageListener.
	                   При приходе сообщения происходит вызов и выполнение кода метода onMessage().
  
+ СЕКЮРИТИ
  > Декларативное управление безопасностью
    --------------------------------------
  [2] Конфигурирование аутентификации
    <login-config>
	    <auth-method>BASIC</auth-method>
    </login-config>
	
  [3] Название ролевой полиики
    <security-role>
	    <role-name>ADMIN_ROLE</role-name>
    </security-role>

  [4] Настройка безопасности для веб-приложения
    <security-constraint>
	    <web-resource-collection>
		    <url-pattern>/admin/*</url-pattern>
		    <http-method>GET</http-method>
		    <http-method>POST</http-method>
	    </web-resource-collection>
	    <auth-constraint>
		    <role-name>ADMIN_ROLE</role-name>
	    </auth-constraint>
    </security-constraint>
	
  > Программное управление безопасностью
    ------------------------------------
  [5] Использование безопасности в сервлетах (в настройках класса-сервлета):
      + '@ServletSecurity' - определяет настройки безопасности;
      + '@HttpMethodConstraint' - ограничения для каждого метода доступа;
      + 'value' - http method (GET,POST..);
      + 'rolesAllowed' - роль которая может получить доступ;
    >> @DeclareRoles ... перечисляет роли для проверки прав доступа к EJB-компоненту
    >> @RolesAllowed ... сообщает контейнеру список ролей которым позволено обращаться к методу EJB-компонента (может применятся либо к отдельному методу либо ко всему классу)
    >> @PermitAll ...... открывает доступ сразу ко всем
    >> @DenyAll ........ закрывает доступ сразу ко всем (делает недоступным класс или метод для любой роли)
    >> @RunAs .......... позволяет выполнить команду от имени другого пользователя (можно временно присвоить пользователю с одной-ролью привилегии с другой ролью)

  > Spring управление безопасностью
    -------------------------------
*       >    'Authentication' -  хранит (объединяет) имя пользователя и пароль в объект (и передается экземпляру 'AuthenticationManager' для проверки)
*                                пользователю будет предложено войти в систему предоставив имя (логин или email) и пароль
*                                представляет пользователя (Principal):
*                                # 'UserDetails' - предоставляет информацию для построения объекта 'Authentication' из DAO-объектов;
*                                # 'UserDetailsService' - создает 'UserDetails';
*            'GrantedAuthority' - представляет роли выданные пользователю в масштабе всего приложения
*       (1)> Если аутентификация прошла успешно возвращает полностью заполненный объект 'Authentication'
*            Инначе будет выброшено исключение 'BadCredentialsException' (с сообщением "Bad Credentials")
*       (2)> 'SecurityContext' - для пользователя устанавливается контекст безопасности
*                                в контексте безопасности храниться вся информация об аутентификации (логин/пароль пользователя) и авторизации (правила авторизации)
*                                (содержит объект 'Authentication' И информацию системы безопасности 'GrantedAuthority' связанную с запросом от пользователя)
*       (3)> 'SecurityContextHolder' - содержит полную информацию о текущем контексте безопасности приложения
*                                      и устанавливает стратегии для хранения информации-'SecurityContext':
*                                      #1 'MODE_THREADLOCAL' локальный поток (по умолчанию);
*                                      #2 'MODE_GLOBAL' глобальный поток;
*                                      #3 'MODE_INHERITABLETHREADLOCAL' порожденные от одного защищенного потока;
*                                      Например: в веб-приложении сервер кэширует информацию пользователя (принципала) в течение сессии и хранит 'SecurityContext' как атрибут 'HttpSession' между HTTP-запросами
*                                                (объект 'SecurityContext' извлекается из 'HttpSession' и восстанавливает контекст в 'SecurityContextHolder' для каждого запроса И очищает 'SecurityContextHolder' после завершения запроса)
*                                                Другие типы приложений, например: 'RESTful веб-сервисы' без сохранения состояния НЕиспользуют HTTP-сессии и будут требовать аутентификации при каждом запросе
*       >    Авторизированный доступ можно прикручивать на:
*            - URL-адресса ... <intercept-url pattern="/add*" access="ROLE_USER"/>
*            - методы ........ <global-method-security secured-annotations="enabled" /> | @Secured("ROLE_ADMIN")
*       >    Форма (способ) аутентификации может быть:
*            - базовый
*            - на форму
*            - ...
*       >    Декларация Spring Security через xml-конфигурацию:
*            - окружаем HTTP-запросы фильтром чтобы гарантировать их защищенность (включаем в web.xml делегирование 'DelegatingFilterProxy' И описываем в '<filter>','<filter-mapping>')
*            - определяем xml-файл с настройками Spring Security ( security.xml ) для получения защищенного web-приложения
*            - добавляем ссылки расположение на Spring Security xml-конфигурации (security.xml) в web.xml и перечисляем их: '<context-param>','<param-value>'

+ КАК РАБОТАЕТ МЕХАНИЗИ OAUTH
  - OpenID - (это чистая 'аутентификация') просто предоставляет информацию о клиенте со стороны другого сервиса (например: используется для быстрой регистрации клиента)
  - OAuth - (это чистая 'авторизация') позволяет программе от пользователя получить права (обозначаются токеном) для пользованием например каким-либо API на стороне другого-доверенного сайта
  http://softwaremaniacs.org/blog/2011/07/14/openid-oauth-difference/
*       > Что такое механихм OAuth - это способ защиты клиентского доступа.
*         Всю доверенность получает и контролирует уже НЕ сам клиент а серверное приложение.
*       > Токен - представляет собой подпись клиента, которая потом идентифицируется на стороне сервера...
*       > Есть OAuth-сервер - который выдает клиенту его токены ('рефреш-токен' и 'актив-токен')
*       > OAuth2Tokenizer - это реализация механизма клиентской автоматической аторизации на серверном приложении.
*       >> НЕавторизированный клиент идет на серверное приложение.
*          Серверное приложение проверяет его и перенаправляет на OAuth-сервер для получения клиентских токенов доступа.
*          Клиент авторизируется на этом OAuth-сервере, получает (свои) клиентские токены доступа.
*          Дальше клиент возвращается на сервер приложений и заходит уже со своими токенами.
*          После этого клиент получает доступ к методам серверного приложения.
*       >> 'рефреш-токен' это механизм авторизации клиента на серверном приложении.
*          Рефреш-токен содержит: ссылку на идентификатор рефреш-токена; OAuth-сервер; зашифрованный клиентский ключ-пароль; ключ-дешифратор;
*       >> 'актив-токен' это клиентская подпись, которая аудитенфицирует личность клиента.
*          Актив-токен содержит: имя клиента; время пользования и время истечения срока для токена; роллевую группу куда входит этот клиент; ссылка на идентификатор рефреш-токен.
*       >> И рефреш-токен и актив-токен хранятся в куках на сторое клиента.
*          Но рефреш-токен может отправляться редко-только один раз на сервер. А актив-токен часто-постоянно каждый раз при запросе отправляется на сервер.
*          Если злоумышленик перехватить актив-токен клиента - то он сможет только на короткое время им воспользоваться.
*          По истечению этого лимитного времени, серверное приложение запросит у клиента его рефреш-токен.
*          Если рефреш-токена нет - тогда доступ для такого клиента будет закрыт...
*          По рефреш-токену серверное приложение автоматически подключается к OAuth-серверу, получает информацию-подтверждения прав доступа клиента и обновляет данные клиентских токенов...
*          Для работы с токенами нужно чтобы сессия была отключена (инначе вся информация будет закешированна внутри сессии по идентификатору сессии)
*          В отличии от актив-токена, рефреш-токен очень редко участвует в клиентских запросах и поэтому вероятность что злоумышленик перехватит его будет очень низкая...
  .....................................................................................
  Токен (тоже являектся кукой, на стороне клиента)
  Наличие и время жизни токенов (куки) контролируется веб-браузером (программой), через время жизни этого токена...
  После удаления токена веб-браузером, в этом случае клиент теряет необходимые данные...и эти (куки) токены уже не восстанавливаются

+ https://habrahabr.ru/company/luxoft/blog/157273/
  > 'Locks' .................... представляет собой альтернативные и более гибкие механизмы синхронизации потоков по сравнению с базовыми synchronized, wait, notify, notifyAll.
  > 'Atomics' .................. классы с поддержкой атомарных операций над примитивами и ссылками.
  > 'Concurrent Collections' ... набор коллекций, более эффективно работающие в многопоточной среде нежели стандартные универсальные коллекции из java.util пакета. Вместо базового враппера Collections.synchronizedList с блокированием доступа ко всей коллекции используются блокировки по сегментам данных или же оптимизируется работа для параллельного чтения данных по wait-free алгоритмам.
  > 'Queues' ................... неблокирующие и блокирующие очереди с поддержкой многопоточности. Неблокирующие очереди заточены на скорость и работу без блокирования потоков. Блокирующие очереди используются, когда нужно «притормозить» потоки «Producer» или «Consumer», если не выполнены какие-либо условия, например, очередь пуста или перепонена, или же нет свободного «Consumer»'a.
  > 'Synchronizers' ............ вспомогательные утилиты для синхронизации потоков. Представляют собой мощное оружие в «параллельных» вычислениях.
  > 'Executors' ................ содержит в себе отличные фрейморки для создания пулов потоков, планирования работы асинхронных задач с получением результатов.

+ SPRING
* >>>> @Autowired — аннотация создает фабрику (объект-одиночку 'Singleton') для операций обработки...позволяет автоматически установить значение поля SessionFactory.
*                   Аннотация @Autowired может применяться к: полям бина, сеттерам, конструкторам и другим методам - чтобы заинъектить в них зависимости
*                   Еще у @Autowired есть необязательное свойство 'required', при «required=false» Spring не будет кидать исключение если не найдет в контексте необходимого бина.
*                   Существует четыре вида связывания в Spring-е (кторые поддерживает автовайред при иньекции бина):
*                   1. Autowire по имени;
*                   2. Autowire по типу;
*                   3. Autowire в конструкторе (по имени, по типу, по индексу);
*                   4. Autowiring by @Autowired and @Qualifier annotations (модифицированный);
*                   Cвязь между компонентами (DI - иньекция зависимостей):
*                   - выполнена через поле класса – 'Setter Injection' (SI);
*                   - или с использованием конструктора – 'Constructor Injection' (CI)
*                     При использовании Constructor Injection, может возникнуть проблема - Кольцевая Зависимость (когда конструктор класса 'А' требует в качестве параметра экземпляр класса B', а тот в свою очередь требует в констуркторе наличие класса 'A')
*                     В этом случае Spring не сможет выполнить иньекцию экземпляров упомянутых компонент И выбросит ексепсиш 'BeanCurrentlyInCreationException'
* >>>> @Inject — аннотация позволяет иньектировать реализацию объекта по интерфейсу... 
* >>>> @Qualifier — аннотация позволяет несколько специфицировать бин, который необходим для @Autowired. Qualifier принимает один входной параметр имя бина.
* >>>> @Resource —  по действию аналогична @Autowired. В качестве параметра 'name' может принимать имя бина.
* >>>> @Scope("singleton") — ( @Singleton(true) или @Singleton(false) или @Scope("prototype") или @Scope("request") или @Scope("session") или @Scope("global-session") )
*
* >>>>> BeanFactory — это реализация паттерна Фабрика для создание бинов.
* >>>>> ApplicationContext — (из-за большей функциональности рекомендуется использование вместо BeanFactory) может быть использован для загрузки и связывания бинов.
*                            Существует 3 основных реализации:
*                            1. ClassPathXmlApplicationContext (получает информацию из xml-файла, находящегося в classpath)
*                            2. FileSystemXmlApplicationContext (получает информацию из xml-файла)
*                            3. XmlWebApplicationContext (получает информацию из xml-файла за пределами web-приложения)
*
* >> Области видимости (scopes) бинов:
*   1. singleton - (по умолчанию) IoC контейнер создает единственный экземпляр бина без сохранения состояния (stateless);
*   2. prototype - Spring IoC контейнер создает любое количество экземпляров бина с сохранением состояния (stateful);
*   3. request - жизненный цикл экземпляра ограничен единственным HTTP-запросом;
*   4. session - жизненный цикл экземпляра ограничен в пределах одной (HTTP) сессией;
*   5. global session - жизненный цикл экземпляра ограничен в пределах глобальной (HTTP) сессией;
*   6. application - жизненный цикл экземпляра ограничен в пределах ServletContext;
* 
* После выхода четвертой версии спринга, у нас появилось четыре способа конфигурирования контекста:
* 1. Конфигурация через аннотации с указанием пакета для сканирования .............................................. AnnotationConfigApplicationContext(“package.name”)
* 2. Конфигурация через аннотации с указанием класса (или массива классов) помеченного аннотацией @Configuration ... AnnotationConfigApplicationContext(JavaConfig.class). Этот способ конфигурации называется — JavaConfig.
* 3. Xml конфигурация .............................................................................................. ClassPathXmlApplicationContext(“context.xml”)
* 4. Groovy конфигурация ........................................................................................... GenericGroovyApplicationContext(“context.groovy”)
  ====================== (1) property.properties, (2) ClassConfig.java, (3) context.xml, (4) context,groovy ======================

* Бин в Spring используется для ссылки на любой компонент, управляемый контейнером.
* Существует несколько способов работы с классами как Spring Bean (XML конфигурация, Java based конфигурация, Annotation based конфигурация)
* В Spring предусмотрен дополнительный механизм связывания @Autowired (чтобы аннотация заработала необходимо указать настройки в конфигурационном файле спринг 'context:annotation-config').
* По умолчанию бин задается как 'синглтон' в Spring. Таким образом все публичные  переменные класса могут быть изменены одновременно из разных мест. Поэтому Spring Bean не является потокобезопасным.
* Однако поменяв область действия бина на: 'request', 'prototype', 'session' - он станет потокобезопасным (но это скажется на производительности).
* 
* По сути можно класс с любым скоупом определять в любом классе с другим скоупом...но при этом:
* - 'Singleton' бин всегда существует только в единственном экземпляре(является потоко-НЕбезопасным) И всегда будет существовать... 
                Если 'Singleton' бин является зависимым для для другого объекта (то есть внутри другого объекта будет объявлено поле типа-класса 'Singleton') 
				>> тогда при удалении этого другого-объекта ничего страшного НЕпроизойдет (объект удачно удалиться и программа успешно будет продолжать работать...)
* - 'Prototype' бин (или любой другой) существуют во многих экземплярах НО будет существовать только лиш кратковременно... 
                Если 'Prototype' бин является зависимым для для Singleton-объекта (то есть внутри Singleton-объекта будет объявлено поле типа-класса 'Prototype') 
				>> тогда при удалении этого другого-объекта удалиться и ссылка на него И это приведет к ошибке 'NullPointerException'
* В 'Singleton' бине можно успешно создавать разовые объекты для генерации например случайных чисел И такие разовые объекты успешно будут работать для всех других объектов...
*
* Чтобы можно было связывать бин обладающий меньшей областью видимости (например, session) с бином, у которого область видимости больше (например, singleton) необходимо вставлять не сами бины, а их прокси объекты
* Самое интересное начинается, когда бин (Bean) со скоупом 'prototype' вставляют в singleton-бин. Тогда появляется понятие "Прокси": 
*   @Component
*   @Scope(value = "session", proxyMode = ScopedProxyMode.INTERFACES) 
*   public class MyUserData { 
*     //... 
*   }
*
*   @Bean(scope = DefaultScopes.SESSION) 
*   @ScopedProxy
*   public UserPreferences userPreferences() { 
*     return new UserPreferences();
*   }
*
* При использовании Constructor Injection, может возникнуть еще одна проблема, известная как Кольцевая Зависимость (Circular dependencies). Представьте себе ситуацию, когда конструктор класса А требует в качестве параметра экземпляр класса B, а тот в свою очередь требует в констуркторе наличие класса A!? В этом случае, Spring Framework, не сможет „поднять“ экземпляры упомянутых компонент (beans), и выбросит исключительную ситуацию: BeanCurrentlyInCreationException. Выходом из подобной ситуации будет переход к Setter Injection. В этом случае при создании объектов, поля будут проинициализиорованы null и только в следующем проходе Spring выполнит Setter Injection.
*
* >>>> @Autowired — аннотация создает фабрику (объект-одиночку 'Singleton') для операций обработки...позволяет автоматически установить значение поля SessionFactory.
*                   аннотация @Autowired может применяться к: полям бина, сеттерам, конструкторам и другим методам - чтобы заинъектить в них зависимости
*                   еще у @Autowired есть необязательное свойство 'required', при «required=false» Spring не будет кидать исключение если не найдет в контексте необходимого бина.
*                   Существует четыре вида связывания в Spring-е (кторые поддерживает автовайред при иньекции бина):
*                   1. Autowire по имени;
*                   2. Autowire по типу;
*                   3. Autowire в конструкторе (по имени, по типу, по индексу);
*                   4. Autowiring by @Autowired and @Qualifier annotations (модифицированный);
*                        Cвязь между компонентами (DI - иньекция зависимостей):
*                        - выполнена через поле класса – 'Setter Injection' (SI);
*                        - или с использованием конструктора – 'Constructor Injection' (CI)
*                   При использовании Constructor Injection, может возникнуть проблема - Кольцевая Зависимость (когда конструктор класса 'А' требует в качестве параметра экземпляр класса B', а тот в свою очередь требует в констуркторе наличие класса 'A')
*                   в этом случае Spring не сможет выполнить иньекцию экземпляров упомянутых компонент И выбросит ексепсиш 'BeanCurrentlyInCreationException'
* >>>> @Inject — аннотация позволяет иньектировать реализацию объекта по интерфейсу... 
* >>>> @Qualifier — аннотация позволяет несколько специфицировать бин, который необходим для @Autowired. Qualifier принимает один входной параметр имя бина.
* >>>> @Resource —  по действию аналогична @Autowired. В качестве параметра 'name' может принимать имя бина.


+ JAX-WS
 * @WebService — указывает на то, что Java класс (или интерфейс) является веб-службой
 * @WebMethod — позволяет настроить то, как будет отображаться метод класса на операцию веб-службы
 * @WebParam — позволяет настроить то, как будет отображаться конкретный параметр операции на WSDL-часть (part) и XML элемент
 * @WebResult — позволяет настроить то, как будет отображаться возвращаемое значение операции на WSDL-часть (part) и XML элемент
 * @Oneway — указывает на то, что операция является односторонней, то есть не имеет выходных параметров
 * @SOAPBinding — позволяет настроить то, как будет отображаться веб-служба на протокол SOAP
 * 
 * 1. Создать интерфейс, описывающий будущий сервис. Аннотациями отметить методы и аргументы как на примере ниже:
				@WebService(name="EntityPortMyType", targetNamespace = "http://my.domain.com/ws/definitions")
				public interface EntityManager{
				    @WebMethod
				    long addEntity();
				
				    @WebMethod
				    long findEntity( @WebParam(name = "type")IdentityType i_type, @WebParam(name = "identity")String identity );
				
				    @WebMethod
				    void removeEntity( @WebParam(name = "id")long id );
				}
 * 2. Создать класс-реализацию интерфейса. Несколько тонких моментов (обратить внимание на аннотации класса, реализующего интерфейс):
 *      portName        - должен указывать на порт того типа, что прописан в интерфейсе
 *      targetNamespace - должен быть такой же, как и у интерфейса
 *      endpointInterface - точно указывать на полное имя реализуемого интерфейса
 *      wsdlLocation - (cамое главное) должен непременно указывать на папку wsdl в каталоге WEB-INF
				@WebService(serviceName = "EntityManager",
				            portName="EntityPortMyType",
				            endpointInterface = "com.mydomain.webapp.domain.EntityManager",
				            targetNamespace = "http://my.domain.com/ws/definitions",
				            wsdlLocation = "WEB-INF/wsdl/EntityManager.wsdl")
				
				public class EntityManagerImpl implements EntityManager{
				    public long addEntity(){
				        // method body
				        return 0;
				    }
				
				    public long findEntity(IdentityType i_type, String identity){
				        // method body
				        return 0;
				    }
				
				    public void removeEntity(long id){
				       // method body
				    }
				}
 * 3. В pom файле проекта необходимо совершить: 
 *    - вставить код для jaxws-maven плагина, 
 *    - обязательно прописав параметр resourceDestDir (иначе сгенерированные wsdl и xsd файлы окажутся где-то еще, но не там, где им необходимо быть)
				<plugin>
				        <groupId>org.codehaus.mojo</groupId>
				        <artifactId>jaxws-maven-plugin</artifactId>
				        <executions>
				            <execution>
				                <goals>
				                    <goal>wsgen</goal>
				                </goals>
				            </execution>
				        </executions>
				        <configuration>
				            <resourceDestDir>${basedir}/src/main/webapp/WEB-INF/wsdl</resourceDestDir>
				            <sei>com.my.domain.webapp.domain.EntityManagerImpl</sei>
				            <genWsdl>true</genWsdl>
				            <keep>true</keep>
				            <packageName>com.my.domain.webapp.domain</packageName>
				        </configuration>
				</plugin>
				<dependency>
				     <groupId>com.sun.xml.ws</groupId>
				     <artifactId>jaxws-rt</artifactId>
				     <version>2.1.3</version>
				</dependency>
 * 4. Для работы в Tomcat необходимо как обычно в web.xml файле прописать путь и прицепить сервлет для обработки URL:
 *    - Сервлет (com.sun.xml.ws.transport.http.servlet.WSServlet)
 *    - Обработчик (com.sun.xml.ws.transport.http.servlet.WSServletContextListener)
				 <listener>
				    <listener-class>
				        com.sun.xml.ws.transport.http.servlet.WSServletContextListener
				    </listener-class>
				</listener>
				
				<servlet id="ws-entities-servlet">
				    <servlet-name>EntityService</servlet-name>
				    <servlet-class>
				        com.sun.xml.ws.transport.http.servlet.WSServlet
				    </servlet-class>
				    <load-on-startup>1</load-on-startup>
				</servlet>
				<servlet-mapping id="ws-entities-servlet-mapping">
				    <servlet-name>EntityService</servlet-name>
				    <url-pattern>/app/entities</url-pattern>
				</servlet-mapping>
 * 5. Создать файл sun-jaxws.xml 
 *      Но что же сервлет будет делать с запросом, пришедшим на url-pattern?
 *      В данный момент ему его деть некуда и он вернет ошибку 404. Чтобы исправить эту ситуацию, надо создать файл sun-jaxws.xml в директории WEB-INF проекта и вписать туда следующие строчки:
				<?xml version="1.0" encoding="UTF-8"?>
				<endpoints
				        xmlns="http://java.sun.com/xml/ns/jax-ws/ri/runtime"
				        version="2.0">
				    <endpoint name="EntityManager"
				            implementation="com.my.domain.webapp.domain.EntityManagerImpl"
				            url-pattern="/app/entities"/>
				</endpoints>
 * 6. Собрав проект и запустив Tomcat, можно обратиться по следующему URL и посмотреть на WSDL файл веб сервиса
				http://localhost:8080/my-webapp/app/entities?wsdl



ConcurrentLinkedQueue:
.element()
.pull()
.peek()
.pop()

++++++++++++++++++++++++++++++++++++++
Стек - это структура данных, хранящая объекты в порядке "первым вошел, последним вышел" или "последним вошел, первым вышел".
       Обычно у этой структуры есть API с такими методами, как push() и pop(). Иногда присутствует метод peek().

Метод push() - принимает входной объект (например: foo и помещает его во внутренний контейнер; например: массив).
               Метод push() обычно ничего не возвращает.

Если передать методу push() два объекта, например, сначала foo, а потом bar - второй объект bar должен оказаться наверху концептуального стека, содержащего по крайней мере два объекта, так что при вызове метода pop() объект bar должен быть извлечен первым, до первого объекта foo. Если метод pop() вызвать еще раз, должен быть возвращен объект foo и стек должен стать пустым.

Метод pop() удаляет самый последний элемент, добавленный в стек - да, метод pop() должен удалить верхний элемент, при этом предполагается, что в стеке есть элементы, чтобы их удалять.

Метод peek() - работает точно также (метод pop()), но при этом объект не удаляется.
               Метод peek() должен оставить верхний элемент в стеке.

Если вызвать метод pop(), когда в стек еще ничего не было добавлено -  метод pop() должен выдать исключение, показывающее, что в стек еще ничего не добавлялось.

Если выполнить команду push() null - стек должен выдать исключение, так как null не является допустимым значением для метода push(). 
++++++++++++++++++++++++++++++++++++++
Akka - заботится о потоках и синхронизации...
Spray - это простой но мощный инструмент для построения REST/HTTP сервисов (ничего лишнего)
Play! - это фреймворк для построения RESTFul API (содержит много вещей которые мы не используем)
Slick - работа с базой данных
Scalaz - упрощает программирование в функциональном стиле

ScalaTest - тестирование, близко напоминает тесты в стиле JUnit (удобно)
Specs2 - применяется в стиле модульного тестирования
FlatSpec - для перехода от JUnit-тестированию к использванию BDD-тестирования
Spock - фреймворк для написания тестов в стиле Behaviour-Driven Development (BDD), (для Java и Groovy приложений)

Test-Driven Development (TDD) - это техника программирования, когда модульные тесты пишутся до самой программы
"test-case" (тест кейс) - выполняет одноно типовое действие над исследуемой системой (аргумент1=действие1)
Data-Driven Testing (DDT) - это тесты управляемые данными, когда тестовые данные хранятся отдельно от скриптов
"data-driven" (тест, управляемый данными) - один алгоритм проверки и много вариантов входных данных
Behaviour-Driven Development (BDD) - разработка основанная на функционировании (как программа работает, а не что она производит в конечном итоге)

Simple Build Tool (SBT) - Стандартное средство сборки приложений для Scala
Spark - представляет собой новую кластерную вычислительную среду, обладающую полезными особенностями
Docker - система виртуализации
Agile - это ускоряющая методология создания проектов. Она минимизирует риски посредством коротких (2–3 недели)циклов, или итераций, разработки.
++++++++++++++++++++++++++++++++++++++
Scala, Akka, Multithreading, Algorithms, Machine Learning, Design Patterns
Also have some experience with: Spark, Hadoop, Docker, Play
Методология Agile

Core Java, Concurrency;
J2EE: Servlets, JPA, JMS
Spring: MVC, Security, Data, IOC
Scala: Collections, Akka;
Testing: JUnit, Mockito, Specs2, Spock;
maven, sbt, git, svn;
Linux: Bash scripting, using as server system;

ScalaTest
FlatSpec

Understanding of SQL and NoSQL concepts
Practical Spark experience or Spark MooC certificates is a big plus
Experience in optimising application performance and database queries

+ Low latency\Heavy loaded project
+ Reactive Programming (Kiev Polytechnic Institute)
++++++++++++++++++++++++++++++++++++++





P. 142 | Practice 2
-------------------
#1
Do you go to shcool by car? Yes, I do.
Do they live in New York? Yes, they do.
Do you work at home? No, I don't.
Do they get up early? No, they don't.
Do you have breakfast? Yes, I do.
Do you study in Russian? No, I don't.

#2
Have you live in a flat? No, I haven't.
Are Marek and Monika married? No, they aren't.
Have your parents go out a lot? Yes, they have.
Heve you got a new computer? No, I haven't.
Do you have launch in a cafe at the weekend? Yes, I have.
Have you work in the city centre? No, I haven't.
Are they fron Italy? No, they aren't.


P. 143 | Practice 3
-------------------
#1
1)  6:05
2) 10:35
3)  8:30
4) 10:20
5) 11:40
6)  3:15
7)  9:00
8)  9:45

#2
a) half past three
b) quarter past six
c) ten past five
d) elevent oclock
e) quarter to six
f) twenty-five to ten
g) five to four
h) twenty past seven
i) twenty to ten
j) five past one


P. 143 | Remember these words
-----------------------------
>> (Предлоги) http://english-tutorial.ru/grammar-96/
 -=ЕСЛИ ПРИСУТСТВУЕТ СЛОВО ЧТО УКАЗЫВАЕТ НА ВРЕМЯ=-
0. предлог не ставится если выражение включает одно из слов: 'next','last','this','that','one','any','each','every','some','all'
   перед названиями дней в разговорной речи часто опускается предлог 'on' а периодичность может обозначаться словами days, nights, mornings, evenings, afternoons.
 -=ВРЕМЯ ЧТО ВНУТРИ МЕНЕЕ-СУТОК=-
1.          'at' используется для обозначения внутрисуточного времени: at 10 o’clock, at 7.45, at midnight, at night, at dinner.
   ставится перед словами выражающими периодичность или сиюминутность: at the weekend, at weekends.
                                                 популярные праздники: at Christmas, at New Year, at Easter.
                                                    отдельные моменты: at the moment, at present, at the same time.
 -=ДЛЯ ДАТ, ДЛЯ (ДАТ)ПРАЗДНИЧНЫХ ДНЕЙ, ДЛЯ (ДАТ)ДНЕЙ НЕДЕЛИ=-
2.                                        'on' используется для обозначения дней недели: on Monday, on Tuesdays.
                                                                       даты и праздники: on 21 March 1996, on April 1st, on Christmas Day, on my birthday
   если перед временем суток указан день недели то словосочетание идет с предлогом 'on': on Saturday morning, on Sunday evening
 -=ВРЕМЯ НА БОЛЕЕ ДЛИТЕЛЬНЫЕ-ПЕРИОДЫ И ВРЕМЯ НА ПРОМЕЖУТОК ВРЕМЕНИ=-
3. 'in','in the' характеризует наиболее продолжительные периоды (месяцы, сезоны, года): in January, in (the) winter, in 1984, in the 1960s, in the 20th century, in the past, in (the) future.
                 еще 'in','in the' определяет за какой промежуток выполняется действие: in the morning(s), in the afternoon(s), in the evening(s), in the night. Окончание -s указывает на то что событие повторяется каждый упомянутый период.
-----------------------------
>> (Английские предлоги места) http://online-teacher.ru/study/english-predlogi-mesta
1.          'at' находится временное-короткое-время где-то внутри чего-то: at the railway station, at the theatre, at the birthday party
2. 'on' находится временное-короткое-время возле,около,на чем-либо сверху: on the right side, on the sixth floor, on the radio, on TV
3. 'in','in the' находится более-длительное-время где-то внутри (в рамках) чего-то: in Berlin, in the train, in the letter
+. next to, beside, by: непосредственно рядом, очень близко от чего-либо
+. under: расположение ниже/под чего-либо
+. below: расположение ниже какого-либо уровня
+. over: расположение сверху (на поверхности) чего-либо
+. above: расположение над чем-либо (выше)
+. across: расположение с другой стороны; переход на другую сторону чего-либо
+. through: прохождение насквозь, движение сквозь что-либо
+. to: движение по направлению к кому-либо или к чему-либо
+. into: движение, перемещение внутрь чего-либо
+. towards: движение по направлению к чему-либо или кому-либо, приближение без необходимости достижения цели
+. onto: движение, перемещение наверх
+. from: движение откуда-либо, от какой-то отправной точки; указание на происхождение

There is a great difference between her wishes and his possibilities. == ЧТО-ТО-НЕЧТО ГДЕ-ТО-ТАМ существует огромная разница между ее желаниями и его возможностями.
-----------------------------
 -=МЕСТО=-
a cinema ........... кинотеатр
a swimming pool .... басейн
a beach ............ пляж
a park ............. парк
a block of flats ... блочный дом (для жилья)
a restaurant ....... ресторан
  small shops ...... магазин
a supermarket ...... супермаркет
a street market .... рынок
a shopping center .. (сеть магазинов)
 a town ............ (маленький) городок
 a city ............ (большой) город
 a village ......... село
 -=ВРЕМЯ=-
at midday .......... в (конкретно-точно) полдень (= одного дня..)
at lunchtime ....... в (конкретно-точно) время обеда (= одного дня..)
at midnight ........ в (конкретно-точно) полночь (= одного дня..)

at the weekend ..... в этот (конкретно-точно) выходной день (= одного дня..)

in the morning ..... в течении утра (в один из какого-нибудь часа = между-через..)
in the afternoon ... в течении после обеда (полудень - в один из какого-нибудь часа = между-через..)
in the evening ..... в течении вечера (в один из какого-нибудь часа = между-через..)

on weekdays ........ в один из (какой-нибудь день) будних дней (в течении рабочей недели = на протяжении..)
 -=ДЕЙСТВИЕ=-
to open ............ (делать) открывать
to close ........... (делать) приближаться
to finish .......... (делать) останавливаться
 -=...=-
by bus ............. НА автобусе

#1
1. I LIVE in a big flat in Milan.
2. They HAVE breakfast in a cafe at the weekend.
3. We STUDY English after school.
4. I GET UP at 6:00 in the morning.
5. You GO to scool by bus and train.
6. I WORK long hours for a big company.

#2
1. I get up AT half past seven.
2. They play football ON Saturdays.
3. Do you have lunch AT midday?
4. I don't work AT the weekend.
5. Do they sleep IN the afernoons?
6. I go to bed early ON weekdays.
7. We wotch TV IN the evenings.
8. They shops close AT lunchtime.

P. 31 | Useful language
#A.
1. Most people live in flats in the city.
2. Children start school at half-past eight.
3. Most people have lunch in offices.
4. Shops close at 13:00 oclock for lunchtime.
5. Yes, they do.
6. Restaurants close at 11:00 p.m.
7. Yes, it does.
8. People have dinner at 8:00 p.m.

#B.
1. Most people live in flats in the city.
2. Most people don't live in the city centre.
3. Children start school at 8:30 a.m., and finish school at 2:30 p.m.
4. Most people don't go home for lunch, because they have lunch in offices.
5. Most shops open at 9:00 a.m. and close at 21:00 o'clock.
6. Most people have lunch at 12:00 o'clock and have dinner at 20:00 oclock.
7. Restaurants open at 9:00 a.m. and close at 9:00 p.m.


(H/W) P. 34
-----------
>> () http://englishbigidea.blogspot.com/2013/12/Like-love-hate-prefer.html
#1
# из инфинитива (ing) в >> I go for walks on holiday...
going for walks ................ гулять
dancing ........................ танцевать
cycling ........................ ездить на велосипеде
reading ........................ читать
cooking ........................ готовить
spending time with friends ..... проводить время с друзъями
plaing computer games .......... играит в компьютерные игры
wathing sport .................. смотреть спорт
spending time on the internet .. проводить время в интернете
swimming ....................... плавать

> I go for walks on holidays.
> I never dance.
> Sometimes I ride a bicycle.
> I often read books.
> Sometimes I cook.
> Sometimes I spend time with my friends.
> I never play computer games.
> I never wath sport.
> I often spend time on the internet.
> Sometimes I go to swim in the pool.

#2
>> To love ..... любить
>> To like ..... нравится
>> To hate ..... ненавидеть
>> To prefer ... предпочитать
>> To want ..... хотеть 

> Do you go for walks on holiday?
  Yes, I do.
> Do you like dancing?
  No, I don't.
> Do you like cycling?
  Yes, I do.
> Do you like reading books?
  Yes, I do.
> Do you like cooking?
  No, I don't. I hate it.
> How often do you spend time with your friends?
  I spend time with my frends once or twice a month.
> Do you play computer games?
  Yes, I do. I like it.
> Do you watch sport?
  No, I don't.
> How much time do you spend on the internet?
  I spend four or five hourson the internet.
> Do you like swimming?
  Yes, I do. I like swimming.


P. 35 | Practice 1
- - - - - - - - -[ Like/Dislikes with noun and -ing ]
+ Like.
+ Love.
~ Don't mind.
- Hate.
- Can't staund.
- Don't like / Dislike.

She lives in a big house.
She doesn't like doing big concerts.
She likes comfortable clothes.
She hates the food on aeroplanes.
She doesn't like flying.
She loves singing.
------------------
#1a
1.        (go for restaurants) > She hates going to restaurants.
2. (go for walks with her dog) > She likes going for walks with her dog.
3.                       (fly) > She doesn't like flying.
4.                (her mother) > She loves her mother;
5.   (spend time with friends) > She likes spending time with friends 
6.           (do big concerts) > She doesn't like doing big concerts.
7.             (black clothes) > She hates black clothes.
8.    (the food on aeroplanes) > She hates the food on aeroplanes.

  
  
  
  
  
  


  
  
  




(mongodb test)
https://www.tutorialspoint.com/mongodb/mongodb_mock_test.htm
https://github.com/mongodb/mongo/wiki/Test-The-Mongodb-Server
https://docs.mongodb.com/getting-started/shell/import-data/
(How to Load Test MongoDB with JMeter) https://www.blazemeter.com/blog/how-load-test-mongodb-jmeter
https://www.owasp.org/index.php/Testing_for_NoSQL_injection
(spring mongodb test)
http://stackoverflow.com/questions/29587430/spring-data-mongodb-junit-test
(embedded mongodb java)
http://stackoverflow.com/questions/6437226/embedded-mongodb-when-running-integration-tests
http://www.pretechsol.com/2012/09/java-mongodb-junit-test-with-embedded.html#.WA2_miQhWM8
(nosql java test)
http://www.methodsandtools.com/tools/nosqlunit.php
http://www.slideshare.net/tobiastrelle/no-sql-testautomation
https://dzone.com/articles/testing-spring-data-mongodb-0
https://eclipse.googlesource.com/eclipselink/examples/+/dcf45221d60f9ad69052fa54d87ab286197a52fd/jpa/nosql/mongo/src/test/java/example/Test.java
(Basic Mistakes in Database Testing) https://dzone.com/articles/basic-mistakes-database
(NoSQLUnit) http://lordofthejars.github.io/nosql-unit/nosqlunit.html
			http://www.lordofthejars.com/2012/06/nosqlunit-030-released.html >> https://github.com/lordofthejars/nosql-unit
			https://www.javacodegeeks.com/2012/04/dbunit-spring-and-annotations-for.html >> https://github.com/springtestdbunit/spring-test-dbunit/tree/master/spring-test-dbunit-sample >> http://lordofthejars.github.io/nosql-unit/nosqlunit.pdf
                          (spring nosql database testing)
(Testing Spring Data MongoDB Applications with NoSQLUnit) http://www.lordofthejars.com/2013/01/testing-spring-data-mongodb.html

                 (json validator java)
(Validate JSON against Schema in Java) http://wilddiary.com/validate-json-against-schema-in-java/
                                       https://github.com/daveclayton/json-schema-validator >> https://github.com/daveclayton/json-schema-validator/blob/master/src/main/java/com/github/fge/jsonschema/examples/Example1.java

(Гироборд (Гироскутер / Ховерборд) под Заказ) 5200 грн.
https://www.olx.ua/obyavlenie/girobord-giroskuter-hoverbord-pod-zakaz-IDlkrSv.html#e692397b73

               (opengl шейдеры)
(Шейдеры в libgdx для чайников) https://habrahabr.ru/post/274813/
Kanban
Java 8, Spring, Spring Security, Jetty, NoSQL,
Git, Sonar, TeamCity
Automation Testing
Cassandra, Kafka, Node.js, Backbone.js

Spring: '@Authowired' или 'set-ер' - почему?




https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/160159261748377534
https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/160159261748377567
https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/160159261748377574
https://mail.yandex.ua/?uid=40270829&login=sashakmets#message/160159261748377595



В класе-интерфейса можно создавать поля-переменные, только НУЖНО их сразу-же здесь иннициализировать (типа как finul..)!!!


>> (Столкнулся с такой проблемой - редактировал файл style.css через Notepad++) http://ru.stackoverflow.com/questions/335561/Восстановить-содержимое-файла













PL/SQL — процедурный блочно-структурированный язык.
> Создание пакетов, процедур и функций, хранимых в базе данных.
> Предоставление интерфейса для вызова внешних процедур.
> Поддержка типов данных SQL и внутренних типов PL/SQL.
> Работа с курсором.
> Механизм обработки исключений.

> Не чувствителен к регистру (кроме строковых переменных и констант).
> Каждая конструкция PL/SQL должна заканчиваться символом ;
> Одна конструкция может быть расположена на нескольких строках.

> Блок — основная структурная единица PL/SQL.
  Блок позволяет объединять объявления и операторы, связанные общей логикой.
  >> Может быть анонимным или именованным.
  >> Может содержать вложенные блоки.
  >> Составные части блока:
     секция объявлений;
     тело блока (обязательная часть);
     обработчики исключений.

DECLARE   
  -- Объявление переменных, типов, курсоров и проч. 
BEGIN   
  -- Код программы (обязательная часть блока)
EXCEPTION   
  -- Обработка исключений
END;
/* Многострочные
комментарии… */ 
-- Однострочный комментарий

Переменные:
    Могут иметь тип данных SQL или PL/SQL.
    Объявляются в секциях объявлений блоков PL/SQL.
    Видны внутри блока, в котором они объявлены.
    Получают тип данных при объявлении.
    Могут быть проинициализированы значением при объявлении.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

3 Слайд: Часть 1. Структура кода в PL/SQL
    3.1 Слайд: Блоки PL/SQL
    3.4 Слайд: Объявление переменных
    3.7 Слайд: Операторы выбора (IF)
    3.8 Слайд: Операторы выбора (CASE)
    3.11 Слайд: Операторы цикла (простой LOOP)
    3.12 Слайд: Операторы цикла (WHILE LOOP)
    3.13 Слайд: Операторы цикла (FOR LOOP)
    3.15 Слайд: Операторы перехода (GOTO)
4 Слайд: Часть 2. Основные типы и структуры данных
    4.1 Слайд: Типы данных
    4.4 Слайд: Приведение типов
    4.6 Слайд: Коллекции
    4.9 Слайд: Записи
    4.11 Слайд: Атрибуты типизации
5 Слайд: Часть 3. Взаимодействие с БД
    5.1 Слайд: Извлечение и обработка данных
    5.5 Слайд: Курсоры
    5.12 Слайд: Вызовы SQL в PL/SQL-ном блоке
    5.14 Слайд: Динамический SQL — пример
    5.15 Слайд: Управление изменениями
    5.18 Слайд: Триггеры
6 Слайд: Часть 4. Исключения
    6.1 Слайд: Обработка ошибок
    6.3 Слайд: Предопределенные исключения
    6.4 Слайд: Объявление исключений
7 Слайд: Часть 5. Подпрограммы
    7.1 Слайд: Функции, процедуры
    7.6 Слайд: Параметры
    7.9 Слайд: Перегрузка функций, процедур
    7.11 Слайд: Рекурсивный вызов
8 Слайд: Часть 6. Пакеты PL/SQL
    8.1 Слайд: Структура пакета
    8.3 Слайд: Доступ к элементам пакета
    8.4 Слайд: Инициализация данных пакета
9 Слайд: Часть 7. И еще...
    9.1 Слайд: Получение информации из запроса/блока/функции
    9.3 Слайд: Системные представления
    9.4 Слайд: Механизм заданий (jobs)
    9.7 Слайд: Коротко об sqlplus

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Курсор — получаемый при выполнении запроса результирующий набор записей плюс привязанный к нему указатель текущей записи.
Курсоры:
    Явные (объявляются разработчиком).
    Неявные (не требуют объявления, управляются автоматически).
Состояние курсора — атрибуты:
     %ISOPEN
     %FOUND
     %NOTFOUND
     %ROWCOUNT

Триггеры на события DML (на строку/на операцию).
Триггеры INSTEAD OF.
Триггеры на события DDL.
Триггеры на события уровня схемы/БД

1. Обработка ошибок
2. Предопределенные исключения
3. Объявление исключений
Исключение — ошибка времени выполнения.
    Нормальное выполнение блока прекращается.
    Управление возвращается внешнему (вызвавшему) блоку.
    ...до тех пор, пока исключение не будет «перехвачено» и обработано:
        выдано user-friendly сообщение пользователю;
        записано в лог;
        проигнорировано;

Подпрограмма — именованный блок PL/SQL, который может иметь параметры вызова.
Аналогично анонимным блокам могут быть вложенными.

PROCEDURE процедура (параметры) AS
  -- Объявление переменных, типов, курсоров и проч. 
BEGIN   
  -- Код процедуры (обязательная часть подпрограммы) 
EXCEPTION   
  -- Обработка исключений
END процедура;

Функция
	Возвращает некоторое значение.

FUNCTION функция (параметры) 
  RETURN тип_значения
AS
  -- Объявление переменных, типов, курсоров и проч. 
BEGIN   
  -- Код функции (обязательная часть подпрограммы) 
EXCEPTION   
  -- Обработка исключений
END функция;

Пакет — хранимый объект, объединяющий логически близкие типы, данные, подпрограммы.

CREATE OR REPLACE PACKAGE пакет AS
  TYPE какой_то_тип AS /*...*/;
  какая_то_переменная тип;
  PROCEDURE какая_то_процедура;
  FUNCTION какая_то_функция RETURN тип;
  --...
END пакет;

Утилита SQL*Plus: позволяет выполнять команды SQL и блоки PL/SQL.
sqlplus — работа в окне командной строки
sqlplusw — оконная версия

sqlplus /NOLOG @script.sql param1 param2

/*script.sql*/
-- Определить код возврата при ошибке
WHENEVER SQLERROR EXIT -1 ROLLBACK
-- Подключиться к БД (параметризовано)
CONNECT &1/&2@ORAXE;
-- Включить вывод
SET SERVEROUTPUT ON;
-- Логировать действия в файл
SPOOL test.log;
-- Объявить и присвоить bind-переменную     
var v_cnt NUMBER;
EXEC :v_cnt := 30;
-- Выполнить команду SQL
SELECT * FROM emp WHERE deptno = :v_cnt;
-- Выполнить блок PL/SQL
BEGIN
    dbms_output.put_line('Listed employees for deptno '|| :v_cnt);
END;
/
-- Выйти с кодом "успешно"
EXIT 0;


1. Типы данных
   Простые (скалярные) типы (простые значения без внутренних составляющих):
    NUMBER(точность, масштаб) — число с плавающей точкой;
    CHAR2(размер) — строка постоянной длины;
    VARCHAR2(макс_размер) — строка переменной длины;
    DATE — дата (со временем);
    BOOLEAN — логическое значение;
   Составные типы (структуры из определенных компонент):
    TABLE — коллекция;
    VARRAY — массив;
    RECORD — запись.
   Ссылочные типы: ссылка на объект, например REF CURSOR. 
   LOB типы: «локатор», определяющий расположение больших объектов данных (графика, файлы,...):
    BFILE — внешний двоичный файл;
    BLOB — внутренний двоичный объект;
    CLOB — внутренний символьный объект.
2. Приведение типов
     Явное:
        TO_NUMBER()
        TO_CHAR()
        TO_DATE()
        ...
    Неявное.
3. Коллекции
    Таблицы PL/SQL (TABLE)
    Массивы (VARRAY)
   Методы работы с коллекциями:
    EXISTS(индекс_элемента) — существует ли элемент по индексу?
    COUNT — количество элементов в коллекции.
    LIMIT — размер varray-массива.
    DELETE(с_элемента, по_элемент) — удалить элементы: все; один; диапазон.
    FIRST, LAST — индексы первого и последнего элемента.
    PRIOR(индекс_элемента), NEXT(индекс_элемента) — индексы следующего и предыдущего элемента.
4. Записи (RECORD)
5. Атрибуты типизации
     %TYPE
        Объявление переменной с типом другой переменной.
        Объявление переменной с типом поля таблицы в БД.
     %ROWTYPE
        Объявление переменной типа запись, по структуре соответствующей строке таблицы в БД.

Взаимодействие с БД:
1. Извлечение и обработка данных
2. Курсоры
3. Вызовы SQL в PL/SQL-ном блоке
4. Управление изменениями
5. Триггеры


Управление изменениями
Транзакция — последовательность действий с БД, которая:
    или полностью фиксируется в БД,
    или полностью отменяется.
Все SQL-операторы входят в одну транзакцию до тех пор, пока не будет сделана ее фиксация (COMMIT) или откат (ROLLBACK).
    Уровни изоляции транзакций.

Сложная (поэтапная) логика действий с БД: промежуточные точки отката
-- Начало действий с БД
--...
SAVEPOINT имя; -- Точка отката
-- Логически сгруппированные действия, которые если что следует
-- откатывать вместе без отката всей транзакции
ROLLBACK TO SAVEPOINT имя; 
--...
COMMIT; -- Фиксация транзакции

Фиксация изменений в БД даже при откате транзакции: автономные транзакции
	PRAGMA AUTONOMOUS_TRANSACTION;
Блокировки.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

/* Пакет реализует API доступа к данным сотрудников:
- получение имени сотрудника по его номеру
- получение названия подразделения сотрудника по его номеру
Обращения к БД кешируются.
*/
CREATE OR REPLACE PACKAGE pk_emp AS
    FUNCTION get_name(a_empno NUMBER) RETURN VARCHAR2;
    FUNCTION get_dept(a_empno NUMBER) RETURN VARCHAR2;
END pk_emp;

CREATE OR REPLACE PACKAGE BODY pk_emp AS
    TYPE TStringArray IS TABLE OF VARCHAR2(100) INDEX BY BINARY_INTEGER;
    la_emp TStringArray;
    la_dept TStringArray;
    FUNCTION get_name(a_empno NUMBER) RETURN VARCHAR2
    AS
    BEGIN
        IF NOT la_emp.EXISTS(a_empno) THEN
            SELECT ename INTO la_emp(a_empno)
                FROM emp
                WHERE empno = a_empno;
        END IF;
        RETURN la_emp(a_empno);
    END get_name;
    FUNCTION get_dept(a_empno NUMBER) RETURN VARCHAR2
    AS
    BEGIN
        RETURN la_dept(a_empno);
    END get_dept;
BEGIN
    FOR lc IN (SELECT empno, dname FROM emp e, dept d WHERE d.deptno = e.deptno)
    LOOP
        la_dept(lc.empno) := lc.dname;
    END LOOP;
END pk_emp;
